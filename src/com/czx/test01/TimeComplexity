时间复杂度（Time Complexity）是衡量算法运行时间随输入规模增长而变化的速率的一种方式。它不关心具体执行了多少秒，而是关注基本操作次数与输入规模
n
n 之间的关系，并用渐近表示法（通常是大 O 表示法）来描述。
一、常见的时间复杂度（从小到大）
表格
时间复杂度	名称	示例算法/操作
O
(
1
)
O(1)	常数时间	数组按索引访问、哈希表查找（平均）
O
(
log
⁡
n
)
O(logn)	对数时间	二分查找、平衡二叉搜索树操作
O
(
n
)
O(n)	线性时间	遍历数组、单层循环
O
(
n
log
⁡
n
)
O(nlogn)	线性对数时间	快速排序、归并排序（平均）
O
(
n
2
)
O(n
2
 )	平方时间	冒泡排序、双重嵌套循环
O
(
n
3
)
O(n
3
 )	立方时间	三重嵌套循环
O
(
2
n
)
O(2
n
 )	指数时间	递归求解斐波那契（无记忆化）、子集枚举
O
(
n
!
)
O(n!)	阶乘时间	旅行商问题（暴力枚举所有排列）
二、如何分析时间复杂度？
找出基本操作：比如比较、赋值、加法等。
计算操作次数与
n
n 的关系。
忽略低阶项和常数系数，保留最高阶项。
例如：
3
n
2
+
5
n
+
10
→
O
(
n
2
)
3n
2
 +5n+10→O(n
2
 )
三、例子
例1：单层循环
python

编辑



for i in range(n):
    print(i)
循环执行
n
n 次 → 时间复杂度：
O
(
n
)
O(n)
例2：双重循环
python

编辑



for i in range(n):
    for j in range(n):
        print(i, j)
内层循环执行
n
×
n
=
n
2
n×n=n
2
  次 →
O
(
n
2
)
O(n
2
 )
例3：二分查找
python

编辑



while low <= high:
    mid = (low + high) // 2
    if arr[mid] == target: ...
    elif arr[mid] < target: low = mid + 1
    else: high = mid - 1
每次将问题规模减半 → 最多
log
⁡
2
n
log
2
​
 n 次 →
O
(
log
⁡
n
)
O(logn)
四、注意事项
最坏情况 vs 平均情况 vs 最好情况：通常讨论最坏情况时间复杂度。
空间复杂度是另一个概念，衡量内存使用。
时间复杂度相同的算法，实际运行时间可能因常数因子不同而有差异。
如果你有具体的代码或算法，我可以帮你分析它的时间复杂度！






